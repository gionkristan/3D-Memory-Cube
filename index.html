<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Memory Cube - Pro Version</title>
    <style>
        body { margin: 0; background: #121212; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        .controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { 
            padding: 12px 24px; cursor: pointer; background: #3498db; color: white; 
            border: none; border-radius: 8px; font-weight: bold; pointer-events: auto;
            transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button:hover { background: #2980b9; transform: translateY(-2px); }
        button:active { transform: translateY(0); }
        kbd { background: #333; border-radius: 3px; padding: 2px 5px; border: 1px solid #555; font-family: monospace; color: #00d2ff; }
        h1 { margin: 0 0 10px 0; color: #3498db; letter-spacing: 1px; }
    </style>
</head>
<body>

<div id="ui">
    <h1>Cube Memory Pro</h1>
    <p>Rotate Camera: <strong>Left Click + Drag</strong></p>
    <p>Layers: <kbd>U</kbd> <kbd>D</kbd> <kbd>L</kbd> <kbd>R</kbd> <kbd>F</kbd> <kbd>B</kbd></p>
    <p>Hold <kbd>Shift</kbd> for counter-clockwise</p>
</div>

<div class="controls">
    <button id="scrambleBtn">Scramble</button>
    <button id="giveUpBtn">Solve Cube</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>

<script>
    // ---------------- Scene Setup ----------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(7, 7, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const light = new THREE.PointLight(0xffffff, 0.5);
    light.position.set(10, 20, 10);
    scene.add(light);

    // ---------------- Cube Construction ----------------
    const colors = { 
        R: 0xb71234, L: 0xff5800, 
        U: 0xffffff, D: 0xffd500, 
        F: 0x009b48, B: 0x0046ad, 
        Internal: 0x222222 
    };
    
    const cubelets = [];
    const cubeGroup = new THREE.Group();
    scene.add(cubeGroup);

    for(let x = -1; x <= 1; x++) {
        for(let y = -1; y <= 1; y++) {
            for(let z = -1; z <= 1; z++) {
                const mats = [
                    new THREE.MeshLambertMaterial({color: x === 1 ? colors.R : colors.Internal}),
                    new THREE.MeshLambertMaterial({color: x === -1 ? colors.L : colors.Internal}),
                    new THREE.MeshLambertMaterial({color: y === 1 ? colors.U : colors.Internal}),
                    new THREE.MeshLambertMaterial({color: y === -1 ? colors.D : colors.Internal}),
                    new THREE.MeshLambertMaterial({color: z === 1 ? colors.F : colors.Internal}),
                    new THREE.MeshLambertMaterial({color: z === -1 ? colors.B : colors.Internal})
                ];
                
                const geo = new THREE.BoxGeometry(0.92, 0.92, 0.92);
                const cubelet = new THREE.Mesh(geo, mats);
                cubelet.position.set(x, y, z);
                
                cubelet.userData.homePos = new THREE.Vector3(x, y, z);
                
                cubeGroup.add(cubelet);
                cubelets.push(cubelet);
            }
        }
    }

    // ---------------- Rotation Engine ----------------
    let isRotating = false;
    const moveQueue = [];
    const scrambleMoves = [];

    function addMove(axis, layer, clockwise, record=true) {
        if (moveQueue.length > 5) return;
        moveQueue.push({ axis, layer, clockwise });

        if(record) scrambleMoves.push({ axis, layer, clockwise });

        processQueue();
    }

    function processQueue() {
        if (isRotating || moveQueue.length === 0) return;
        isRotating = true;
        const move = moveQueue.shift();
        executeRotation(move.axis, move.layer, move.clockwise);
    }

    function executeRotation(axis, layerValue, clockwise) {
        const rotationPivot = new THREE.Group();
        scene.add(rotationPivot);

        const activeCubelets = cubelets.filter(c => {
            const worldPos = new THREE.Vector3();
            c.getWorldPosition(worldPos);
            return Math.abs(worldPos[axis] - layerValue) < 0.1;
        });

        activeCubelets.forEach(c => rotationPivot.attach(c));

        const targetRotation = (Math.PI / 2) * (clockwise ? -1 : 1);
        const duration = 200;
        const startTime = performance.now();

        function animate(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            rotationPivot.rotation[axis] = targetRotation * progress;

            if (progress < 1) requestAnimationFrame(animate);
            else {
                rotationPivot.updateMatrixWorld();
                activeCubelets.forEach(c => {
                    cubeGroup.attach(c);
                    c.position.x = Math.round(c.position.x);
                    c.position.y = Math.round(c.position.y);
                    c.position.z = Math.round(c.position.z);
                    c.rotation.set(
                        Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2),
                        Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2),
                        Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2)
                    );
                });
                scene.remove(rotationPivot);
                isRotating = false;
                processQueue();
            }
        }
        requestAnimationFrame(animate);
    }

    // ---------------- Controls ----------------
    window.addEventListener('keydown', (e) => {
        const key = e.key.toUpperCase();
        const ccw = e.shiftKey;
        if(key === 'U') addMove('y', 1, !ccw);
        if(key === 'D') addMove('y', -1, ccw);
        if(key === 'L') addMove('x', -1, ccw);
        if(key === 'R') addMove('x', 1, !ccw);
        if(key === 'F') addMove('z', 1, !ccw);
        if(key === 'B') addMove('z', -1, ccw);
    });

    // ---------------- Scramble ----------------
    document.getElementById('scrambleBtn').onclick = () => {
        if (isRotating || moveQueue.length > 0) return;
        scrambleMoves.length = 0;
        const axes = ['x','y','z'];
        for(let i=0; i<15; i++){
            const axis = axes[Math.floor(Math.random()*3)];
            const layer = Math.round(Math.floor(Math.random()*3)-1); // -1,0,1
            const clockwise = Math.random() > 0.5;
            addMove(axis, layer, clockwise, true);
        }
    };

    // ---------------- Solve ----------------
    document.getElementById('giveUpBtn').onclick = () => {
        if(isRotating || moveQueue.length > 0) return;

        // Only solve if there are scramble moves
        if(scrambleMoves.length === 0) return;

        const solveMoves = scrambleMoves.slice().reverse().map(m => ({
            axis: m.axis,
            layer: Math.round(m.layer),
            clockwise: !m.clockwise
        }));

        solveMoves.forEach(m => addMove(m.axis, m.layer, m.clockwise, false));
    };

    // ---------------- Render ----------------
    function render(){
        requestAnimationFrame(render);
        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    render();
</script>
</body>
</html>
